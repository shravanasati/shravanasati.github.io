[{"categories":null,"contents":"So I have this one friend who constantly boasts about his sub-200 WPM typing speed. I tried competing with him but couldn\u0026rsquo;t manage it above 100 WPM. I decided it was not worth the effort since I could beat him with the help of Python! :)\nWe\u0026rsquo;ll be using the awesome selenium library for this task.\nPrerequisites Just intermediate-level knowledge of Python and HTML tags. That\u0026rsquo;s all. I\u0026rsquo;ll be explaining selenium along the way. This is essentially a selenium tutorial since I love project-based learning.\nWhat is Selenium? Selenium is a browser automation library which has bindings available for several programming languages, including Python. We\u0026rsquo;ll be exploiting the power of the selenium webdriver, which allows us to control the browser programmatically.\nSelenium is mostly used for automated testing purposes, and occasionally to do such cool things.\nInternally, selenium uses webdrivers provided by browsers such as the GeckoDriver for Firefox, the Chromedriver for Chrome and so on to control the browser.\nDevelopment Setup We need three things installed on our system to write selenium scripts - the language libraries, the browser we want to use, and the driver for that specific browser.\nThis used to be a cumbersome process for developers and often led to a lot of confusion among beginners, especially around having drivers on PATH.\nFortunately, the selenium team developed the selenium manager which automatically manages the browser and driver, and ships with language libraries.\nThus all we need to do is to install the selenium library for Python.\nThis is simple:\npip install selenium==4.20.0 (v4.20.0 because I\u0026rsquo;m also using it.)\nIdeally, you should also create a virtual environment to isolate your project dependencies from the system-wide ones. Read more about it here. Some Gotchas Before getting into writing code, I\u0026rsquo;d like to discuss some of the selenium gotchas.\nThe browser knows it is being remotely controlled.\nNone of your logins (cookies to be precise) of any websites, browser settings and extensions will be remembered when the browser is being controlled by selenium.\nEven the browsing history and cookies obtained during the session will not be saved.\nThat means, if you’re performing an action like logging in or clicking the cookie popup, you’d have to do it every time a new session is opened.\nDon’t poke around too much with big websites, they have mechanisms to know a bot is playing with their website. They might IP block you.\nSelenium can’t get around smart captchas like reCAPTCHA, or any captchas for that matter, on its own.\nWriting the Script Let\u0026rsquo;s get to writing the code now.\nFirst of all, let\u0026rsquo;s import the selenium library.\nfrom selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.wait import WebDriverWait import selenium.webdriver.support.expected_conditions as EC from selenium.common.exceptions import NoSuchElementException You might notice that\u0026rsquo;s a lot of imports, but bear with me - I\u0026rsquo;ll explain them as we use them.\nLet\u0026rsquo;s start with opening the monkeytype website using selenium.\ndriver = webdriver.Firefox() driver.get(\u0026#34;https://monkeytype.com\u0026#34;) If you want to use chrome, or any other browser use the respective class present in the webdriver module. For example, Chrome, Edge, Safari, Ie (why?) and so on. Also, if the browser immediately exits after loading the website, add an input() statement at the end of the file.\nThe first time you\u0026rsquo;ll run this script, it might take a lot of time before the browser window is opened since selenium downloads the necessary webdrivers first. After running the script, this is what we see.\nSo we\u0026rsquo;ve visited the MonkeyType website using Selenium. The next step is to interact with the website.\nThe first thing we see is the cookie popup, and since I mentioned before that browsers remove all cookies obtained during the selenium, we\u0026rsquo;ll have to click either accept or reject button everytime the website is opened.\nLet\u0026rsquo;s code clicking the \u0026ldquo;reject non-essential\u0026rdquo; button.\nEverytime we want to interact with a web element using selenium, like clicking or simulate typing, we have to find that element. Selenium provides a neat way to do it - we can use CSS selectors, IDs, classes, XPATH, tag names and so on.\nOpen the browser developer tools (CTRL+Shift+I or F12) and go to the Inspector tab. Click on the element picker icon (or press Ctrl+Shift+C) and click on the reject non-essential button.\nYou\u0026rsquo;ll see the resulting HTML code responsible for that button. Upon looking at the HTML definition of that button, you\u0026rsquo;ll see that this button has a class of rejectAll.\nprint(\u0026#34;clicking reject all\u0026#34;) rejectbutton = driver.find_element(By.CSS_SELECTOR, \u0026#34;button.rejectAll\u0026#34;) rejectbutton.click() The find_element method of the driver takes two arguments - the locator strategy and the locator value. We have used CSS selectors here. The By class (more like an enum) has various locator strategies defined as constants.\nThe click method is straight-forward, we store the element we found in a variable and then call the click method on it.\nNote that the find_element method will raise the NoSuchElementException if it doesn\u0026rsquo;t find the element based on the locator we provided.\nNext, we need to configure the test options. I\u0026rsquo;ve decided to go for the words test with 25 words. That\u0026rsquo;s also easy - just find the elements and click them.\nOpen the dev tools again and pick the words option. We don\u0026rsquo;t find any ID or class associated with this element. Let the dev tools do the heavy lifting, just right click on the element and copy its selector. Do the same for selecting the number of words.\nprint(\u0026#34;selecting words -\u0026gt; 25\u0026#34;) words_btn = driver.find_element(By.CSS_SELECTOR, \u0026#34;div.mode \u0026gt; div:nth-child(2)\u0026#34;) words_btn.click() wait = WebDriverWait(driver, timeout=10, poll_frequency=.5, ignored_exceptions=errors) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, \u0026#34;.wordCount \u0026gt; div:nth-child(2)\u0026#34;))) words_btn = driver.find_element(By.CSS_SELECTOR, \u0026#34;.wordCount \u0026gt; div:nth-child(2)\u0026#34;) words_btn.click() The finding and clicking of elements is the same - however we\u0026rsquo;re also using explicit waits here.\nWaits in selenium, as the name implies, used to wait. While working with selenium, we often need to wait after we\u0026rsquo;ve performed a certain action. Perhaps an element we interacted changes a lot of the webpage structure, or redirects us somewhere else. In these cases, we use waits.\nThere are two kinds of waits in selenium - implicit and explicit waits. Implicit waits are simple, once set for the driver, everytime selenium locates an element it waits for the given number of seconds while simultaneously trying to locate the element. If selenium is unable to find the element even after waiting, it will throw the NoSuchElementException.\ndriver.implicitly_wait(2) This will set an implicit wait for the driver. Note that this is a global setting that applies to every element location call for the entire session. If the element is found, for example, in a second, driver will not wait any longer. It will return element reference and continue executing further.\nAs you might\u0026rsquo;ve already guessed, using implicit waits is not a very good idea. You can never know how long will it take for requests to finish. A better solution is to use explicit waits.\nExplicit waits have a condition associated with them that must evaluate to True before the code can continue executing. An explicit wait can be initialized as follows:\nwait = WebDriverWait(driver, timeout=10, poll_frequency=.5, ignored_exceptions=errors) The driver and timeout argument must be given. The timeout is the max duration you want driver to spend waiting until the given condition evaluates to True. Obviously, you don\u0026rsquo;t want your code to spend an eternity waiting in case the condition can never be True. A TimeoutException will be thrown when the timeout is over.\nThe rest two arguments, poll_frequency and ignored_exeptions tell selenium how long to sleep before evaluating the condition and which exceptions to ignore, if any occur, respectively.\nThe wait object has two public methods - until and until_not.\nwait.until(lambda d: element.is_displayed()) Both until and until_not methods accept a function which takes the driver as argument, and returns a truthy value which will then stop the wait.\nWe can use these methods to wait until a element is visible, present in the DOM and so on. The expected_conditions module we imported above comes with a lot of helpful pre-defined functions that do these tasks. Make sure to check their documentation.\nWe\u0026rsquo;ll use the presence_of_element_located function which returns a predicate that will make the webdriver wait until that element is present in DOM. It takes a locator argument, which is just a tuple of the locator strategy and the locator value.\nwait.until(EC.presence_of_element_located((By.CSS_SELECTOR, \u0026#34;.wordCount \u0026gt; div:nth-child(2)\u0026#34;))) Waiting until the elements are present, and in a desired state before interacting with them is always a good idea.\nDo NOT ever use implicit and explicit waits together in a script. They lead to unpredictable behavior. Whoops, that was a lot of theory. Let\u0026rsquo;s take a look at code accumulated so far. It should open the monkeytype website, click on the \u0026ldquo;reject non-essential\u0026rdquo; button, select words mode and 25 words.\nfrom selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.wait import WebDriverWait import selenium.webdriver.support.expected_conditions as EC from selenium.common.exceptions import NoSuchElementException driver = webdriver.Firefox() driver.get(\u0026#34;https://monkeytype.com\u0026#34;) print(\u0026#34;clicking reject all\u0026#34;) rejectbutton = driver.find_element(By.CSS_SELECTOR, \u0026#34;button.rejectAll\u0026#34;) rejectbutton.click() print(\u0026#34;selecting words -\u0026gt; 25\u0026#34;) words_btn = driver.find_element(By.CSS_SELECTOR, \u0026#34;div.mode \u0026gt; div:nth-child(2)\u0026#34;) words_btn.click() wait = WebDriverWait(driver, timeout=10, poll_frequency=.5, ignored_exceptions=errors) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, \u0026#34;.wordCount \u0026gt; div:nth-child(2)\u0026#34;))) words_btn = driver.find_element(By.CSS_SELECTOR, \u0026#34;.wordCount \u0026gt; div:nth-child(2)\u0026#34;) words_btn.click() Finally, we just need to simulate typing into the monkeytype website.\nfrom time import sleep sleep(2) print(\u0026#34;writing into input\u0026#34;) prompt = driver.find_element(By.CSS_SELECTOR, \u0026#34;input#wordsInput\u0026#34;) words = driver.find_elements(By.CSS_SELECTOR, \u0026#34;div.word\u0026#34;) for word in words: text = \u0026#34;\u0026#34;.join([w.text for w in word.find_elements(By.TAG_NAME, \u0026#34;letter\u0026#34;)]) text = text.strip() prompt.send_keys(f\u0026#34;{text} \u0026#34;) input(\u0026#34;press enter to exit\u0026#34;) driver.quit() First of all, I\u0026rsquo;m doing a dirty practice here by sleeping two seconds instead of using explicit waits. Yeah I will not justify using it.\nThe code finds the input element and stores it in the prompt variable. To simulate typing into the input, we can use the send_keys('text') method on prompt.\nNext, we need to find the words. Similar to the find_element function, find_elements function returns a list of all the elements it could find by the locator. This is because each word on monkeytype is defined like this:\n\u0026lt;div class=\u0026#34;word active\u0026#34;\u0026gt; \u0026lt;letter\u0026gt;l\u0026lt;/letter\u0026gt; \u0026lt;letter\u0026gt;i\u0026lt;/letter\u0026gt; \u0026lt;letter\u0026gt;k\u0026lt;/letter\u0026gt; \u0026lt;letter\u0026gt;e\u0026lt;/letter\u0026gt; \u0026lt;/div\u0026gt; Once we\u0026rsquo;ve grabbed all the words, we need to construct the word by joining the text inside all letter tags. We do it by looping over the word container, then inside each word, we call find_elements for letter tags and grab its inner text. After combining all the letters, we remove all the whitespaces just in case. Finally, we call the send_keys function to type the constructed word and a space (!important).\nThe driver.quit() method closes the browser window. We\u0026rsquo;re waiting for user input before quitting so you can admire the typing speed you can never achieve.\nThe Result I recorded my screen and sent it to my friend. Let\u0026rsquo;s just say, his reaction was pleasing to witness.\nHere\u0026rsquo;s the full code:\nWebsites tend to change a lot - that means the HTML structure changes too. So in the near future, this script might no longer work due to element locators becoming obsolete. Between the time I first wrote the script and the publishing date of this blog, I\u0026rsquo;ve had to modify it twice. But with the knowledge and procedure I\u0026rsquo;ve shared above, you will be able to fix it.\nAnother thing - I tested this script on Firefox, Chrome and Edge - only Firefox had Infinite WPM, the chromium based browsers only did around 400wpm. This just proves why Firefox is superior /s.\nGoing forward The script is barely crossing 30 lines, yet we\u0026rsquo;ve managed to automate monkeytype with selenium.\nYou can modify this program to add some interactivity - like choosing a test mode and further adding options to change parameters like words and time. The code is also quite unorganized. I leave this as exercise to you, the reader; and if you manage to do it, please let me know on my socials (listed below).\nUntil then, bye.\n","date":"May 16, 2024","hero":"/posts/selenium/hero.png","permalink":"http://localhost:1313/posts/selenium/","summary":"So I have this one friend who constantly boasts about his sub-200 WPM typing speed. I tried competing with him but couldn\u0026rsquo;t manage it above 100 WPM. I decided it was not worth the effort since I could beat him with the help of Python! :)\nWe\u0026rsquo;ll be using the awesome selenium library for this task.\nPrerequisites Just intermediate-level knowledge of Python and HTML tags. That\u0026rsquo;s all. I\u0026rsquo;ll be explaining selenium along the way.","tags":null,"title":"Achieving Infinite WPM in MonkeyType using Python"}]